<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
  <script type="text/javascript" src="dat.gui.min.js"></script>
  <script src="https://unpkg.com/mathjs@10.1.0/lib/browser/math.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="names1.js"></script>
  <script type="text/javascript" src="params.js"></script>
  <script type="text/javascript" src="player.js"></script>
  <style>
    body {
      overflow: scroll; /* Show scrollbars */
    }

  </style>
  <title> Speech Visualization Demo</title>
</head>
<body>
<p style="font-size:20px;">
  Instructions:</br>
  Visual show pitch(background color) and amplitude (black curve inside a tile). White spaces are pauses. Each line ends show the same time duration of speech (default 10 seconds) <br>
  Click on any tiled to start a video from that point, click the curve again to stop. <br>
  Change the multiplier for [Amplitude Curve height] or [Font Size] by changing the corresponding value.<br>
  Click [Show/hide Text] and the [Show/hide Stats] to view the text or summary statistics.<br>
  [Norm volume]: normalizes the volume to values between 0 and 1.<br>
  [Alt Colormap]: Change the colormap to Visualize relative pitch changes between (Avg pitch +- 2 sigma)
  [Intonation View]: Check to end a line after a slower speed (Rate of utterance) is detected. Change this value using the [Speed Cutoff] (default "slow speed" is 15 letters/sec). A blue bar at the end indicated an intonation break<br>
  [Phrase View]: Check to end a line after a long pause is detected. Change the value of long pause to cutoff after using the [Postspace Cutoff] (default pause length is 0.3 sec)<br>
  Refresh browser or press Reset Viz to begin again.<br>
  <br>
</p>


<div id="player0" style="width: 600px; height: 600px;left: 85%; top: 60%;position:fixed"></div>
<!-- Create a div where the graph will take place -->
<div class="container" style = "display:flex;width: 80%">
  <div id="my_dataviz" class="fixed"  style = "top: 0px;left: 0px;width: 50%" ></div>
  <div id="my_dataviz2" class="flex-item" style = "flex-grow: 0.5;zoom:200%; top: 30%; margin: 250px 50px 0px 250px;"></div>

</div>
<div id="sliderdiv" class="relative"  style="width: 600px; height: 600px;left: 85%; top: 55%;position:fixed" ></div>
<script>
  // no mean

  function load_audio(path2) {
    var amp ={
      t:[],
      amp:[],
      pit:[],
    }

    d3.csv(path2, function (data) {
      for (var i = 0; i < data.length; i++) {
        amp.t[i] = data[i].time
        amp.amp[i] = data[i].amplitude
        amp.pit[i] = data[i].pitch
      }
    })

    return amp

  }

  function load_data(path) {
    var data_array = {
      words: [],
      //time: [],
      duration:[],
      space:[],
      timeloc:[],
      pitch:[],
      amplitude:[],
      start:[],
      end:[],
      speed:[],

    }


    d3.csv(path, function (data) {
      for (var i = 0; i < data.length; i++) {
        data_array.words[i] = data[i].Word
        //data_array.time[i] = data[i].time
        data_array.duration[i] = data[i].std_time_spent
        data_array.space[i] = data[i].post_space
        data_array.timeloc[i] = data[i].time
        data_array.pitch[i] = data[i].pitch
        data_array.amplitude[i] = data[i].amplitude
        data_array.start[i] = data[i].Start
        data_array.end[i] = data[i].End
        data_array.speed[i] = data[i].speed
      }
    })
    return data_array
  };

  function clear_svg(num){
    d3.select("#my_dataviz").html("")
    //for (i =0; i<num; i++){
    //  d3.select("svg").remove()
    //}
  }
  var amp = [];
  for(i=0; i<paths.length; i++){
    amp[i] = load_audio(paths2[i])

  }
  var data_array = [];
  for(i=0; i<paths.length; i++){
    data_array[i] = load_data(paths[i])

  }

  //console.log(Date.now())
  function make_viz_array(data_array,amp){

    for (i=0; i<num;i++){

      id = names.indexOf(params['name'+i])
      eval('viz'+i+'= new make_viz(data_array[id],amp[id],params,player0, links[id], i,params[\'name\'+i] )')
      eval('viz'+i+'.make_viz()')
      //viz0 = new make_viz(data_array[id],amp[id],params,eval('player'+i), links[id])
      //viz0.make_viz()

    }
    return

  }


  async function f() {
    return 1;
  }

  //f().then(console.log)

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  var num = 0
  var items = [];
  var gui = new dat.GUI({
    width : 500,
    height : 1500,
  });


  parm = gui.addFolder('Parameters')

  gui.add(params, 'num_words').name('Seconds per line').min(3).max(20).step(1).onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array, amp)

  })
  gui.add(params, 'font').name('Font Size').min(1).max(15).step(1).onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)

  })
  gui.add(params, 'ampcurve').name('Amp Height').min(1).max(5).step(0.5).onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  })

  gui.add(params, 'norm').name('Norm Vol').onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  })


  gui.add(params, 'cmap').name('Alt Colormap').onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  })



  gui.add(params, 'pltint').name('Intonation View').listen().onChange(function(){
    if (params.pltint== true){params.height = 7}else{params.height = 1.5}
    clear_svg(num+1)
    make_viz_array(data_array,amp)

  });
  gui.add(params, 'speed').name('Speed Cutoff').min(8).max(30).step(1).onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  })





  gui.add(params, 'pltphrase').name('Phrase View').listen().onChange(function(){
    if (params.pltphrase == true){params.height = 5}else{params.height = 1.5}
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  });
  gui.add(params, 'phrasespacing').name('Postspace cutoff').min(0.05).max(1).step(0.05).onChange(function(){
    clear_svg(num+1)
    make_viz_array(data_array,amp)
  })


  gui.add(params, 'showstats').name('Show/Hide Stats').listen().onChange(function(){
    if (params.showstats == true){params.width = 1.5;params.height = 4.5}else{params.width = 1}
    clear_svg(num+1)
    make_viz_array(data_array,amp)
    /*// Determine if current line is visible
    var active = showstats.active ? false : true,
      newOpacity = active ? 0 : 1;
    // Hide or show the elements
    d3.selectAll("#showstats").style("opacity", newOpacity);
    // Update whether or not the elements are active
    showstats.active = active;*/
  });

  gui.add(params, 'showtext').name('Show/Hide Text').listen().onChange(function(){
    // Determine if current line is visible
    var active = textshow.active ? false : true,
      newOpacity = active ? 0 : 1;
    // Hide or show the elements
    d3.selectAll("#textshow").style("opacity", newOpacity);
    // Update whether or not the elements are active
    textshow.active = active;
  });






  params.resetAnimation =
    function() {
      clear_svg(num+1)
      make_viz_array(data_array,amp)
    };
  setTimeout(params.resetAnimation, 1000)

  gui.add(params,'resetAnimation').name('Reset Viz');
  params.keepplaying = false
  params.name0 = 'Bill Gates'
  params.name1 = 'AlGore'
  params.name2 = 'Celeste Headlee: Better Conversation'
  params.name3 = 'Tim Urban: Procrastinator'
  params.name4 = 'Hyeonseo Lee: Escape from North Korea'
  params.name5 = 'Pamela Meyer: Spot a Liar'
  params.name6 = 'Lera Boroditsky: Language shapes thoughts'
  params.name7 = 'Sir Ken Robinson: Schools kill Creativity',
  params.name8 = 'Finale'
  params.name9 = 'Angela Duckworth: Passion and Perseverance'
  params.subvizx +=12
  params.subvizy +=15
  num +=10;

  /*file = gui.addFolder('Choose Viz')

  var obj = {

    add:function(){
      idx = String(num)
      eval('params.name' + idx + '= []')
      item = gui.add(params, 'name'+idx,names).name('Name '+idx).onChange(function() {
        params.keepplaying = false
        clear_svg(num + 1)
        //player0.loadVideoById(links[names.indexOf(params.name0)], "large")
        eval('player'+idx+'.loadVideoById(links[names.indexOf(params.name'+idx+')])')
        eval('player'+idx+'.pauseVideo()')

        make_viz_array(data_array,amp)

      });


      items.push(item)
      num +=1;
      params.subvizx +=1;
    },

    remove:function(){
      gui.remove(items.pop())
      delete params['name'+num]
      clear_svg(num+1)
      num = num -1
      params.subvizx -=1
      make_viz_array(data_array,amp);}

  };




  gui.add(obj,'add').name('Add Viz');
  gui.add(obj,'remove').name('Remove Viz');*/

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  class make_viz {
    constructor(data_array, amp, params, player, link, id, name) {
      this.data_array = data_array
      this.amp = amp
      this.params = params
      this.player = player
      this.link = link
      this.widthoffset = 0;
      this.linespacing = 24;
      this.xscaleoffset = 0;
      this.n = data_array.words.length
      this.name = 'viz'+id
      this.id = id
      this.title = name
      this.n_print = 500
      this.t = window.performance.now()

    }

    /**
     * returns an array with moving average of the input array
     * -------moving average slider cuts off before the end: edges might not be accurate
     * @param array - the input array
     * @param count - the number of elements to include in the moving average calculation
     */
    movingAvg(array, count, mean) {

      // calculate average for subarray
      var avg = function (subarray,mean) {

        var sum = 0, num = 0, val;
        for (let i = 0; i < subarray.length; i++) {
          if (subarray[i]==""){subarray[i] = mean}
          val = parseFloat(subarray[i]);
          sum += val;

          num++;
        }
        return sum / num;
      };

      var result = array.slice(0, count - 1), val;

      // calculate average for each subarray and add to result
      for (let i = count - 1; i < array.length; i++) {


        val = avg(array.slice(i - Math.floor(count / 2), i + Math.ceil(count / 2)),mean);

        result.push(val);

      }

      return result;

    }

    norm(array){
      var max, min, new_array
      max = d3.max(array)
      min = d3.min(array)
      new_array = array.map(function (value) {return (value-min)/(max-min);})

      return new_array
    }

    notnan (x) {
      return x!=NaN;
    }

    notnoise(array,noiseval) {
      let newarray = array.map(function (value){if (value>noiseval){return value}else{return 0}})
      return newarray
    }





    prep_data(amp){
      var amplitude, pitch
      this.meanpit = 0//math.mean((amp.pit).filter(this.notnan))
      this.meanamp = 0//math.mean((amp.amp).filter(this.notnan))

if (this.params.n_avg>1) {
  this.amplitude = this.movingAvg(amp.amp, this.params.n_avg, this.meanamp)
  this.pitch = this.movingAvg(amp.pit, this.params.n_avg, this.meanpit)
}else{this.amplitude = amp.amp;this.pitch = amp.pit}



      if (params.noise==true){
        this.amplitude = notnoise(amp.amp,this.params.noisefloor)
      }

      function impute(array){
        let num = 0
        let none = 0
        for (let i=0; i< array.length; i++){

          if (array[i] =='') {
            let id1 = i - 1
            while (array[i] == '') {
              i = i + 1
            }
            let id2 = i
            let dif = (+array[id2] - +array[id1]) / (id2 - id1)

            for (let j = id1 + 1; j < id2; j++) {
              array[j] = +array[j - 1] + dif

            }
          }

        }
        return array
      }

      this.opa = new Array(this.pitch.length).fill(1);
      this.pitch = impute(this.pitch)
      this.amplitude = impute(this.amplitude)
      if (params.norm == true){
        this.amplitude = this.norm(this.amplitude)

        //params.ampcurve = 1
      }

    }


    make_scale(){
      var domval
      const t_words = this.params.num_words
      this.xScale = d3.scaleLinear()
        .domain([0, t_words ]) // input
        .range([0, this.width -this.widthoffset ]); // output

      // Y scale input between 0, 1 output in pxls
      this.yScale = d3.scaleLinear()
        .domain([0, 1]) // input
        .range([0, this.params.ampcurve*4 ]); // output

      if (params.ofs==true){domval = [-50,50]}else{domval = [60,300]}

      this.yScale2 = d3.scaleLog()
        .domain(domval) // input
        .range([0, this.params.curve]);
    }

    make_svg(){

      var margin = {top: 50, right: 5, bottom: 50, left: 3}
        , width = (window.innerWidth - margin.left - margin.right)/this.params.subvizx// Use the window's width
        , height = (window.innerHeight - margin.top - margin.bottom) / this.params.subvizy // Use the window's height



      /*var zoomer = d3.zoom()
        .scaleExtent([0.01, 10])
        .on("zoom", zoomed1);

      var slider = d3.selectAll("svg").append("input")
        .datum({})
        .attr("type", "range")
        .attr("value", zoomer.scaleExtent()[0])
        .attr("min", zoomer.scaleExtent()[0])
        .attr("max", zoomer.scaleExtent()[1])
        .attr("step", (zoomer.scaleExtent()[1] - zoomer.scaleExtent()[0]) / 100)
        .on("input", slided(4));

      function zoomed1() {
        slider.property("value",  d3.event.scale);
      }



      function slided(d) {
        //fn(d3.event);
        console.log(d)
        //viz0.svg.attr("transform", "scale(" + d3.select(this).property("value") + ")");
        //viz0.zlvl = d3.event.transform.k
      }


      function callback(x){
        console.log(x);
      }

      function  zoom(d) {
        return d3.zoom().on("zoom", function () {
          zoomed(callback, d)
        });
      }

      function zoomed(fn,x) {
        //fn(d3.event);
        let viz = Function("return " + x)()

        viz.svg.attr("transform", d3.event.transform)
        viz.zlvl = d3.event.transform.k
      }

      on("zoom", function () {
         viz0.svg.attr("transform", d3.event.transform)
         viz0.zlvl = d3.event.transform.k
       })*/

      //console.log(window)

      this.svg = d3.select("#my_dataviz").data([this.name]).append("svg")
        .attr('id','svg'+this.name)
        .attr("width", width*this.params.width)
        .attr("height", 2*height*this.params.height)
        .attr("transform", "translate("+ margin.left+",0)scale(" + params.zoomlvl + ")")
        .attr("overflow", "visible")
        //.call(zoom(this.name))
        .append("g")
        .on("click", addAnother);

      function addAnother() {

        var content2 = d3.select(d3.select("#my_dataviz2")._groups[0][0].firstChild).node()
        d3.select("#my_dataviz2").html("")
        d3.select("#sliderdiv").html("")
        var content = d3.select(this.parentNode).node()

        var cloned = content.cloneNode(true);
        if (content2 != null){d3.select("#my_dataviz").node().appendChild(content2)}
        d3.select("#my_dataviz2").node().appendChild(content);


        var zoom = d3.zoom()
          .scaleExtent([1, 3])
          .on("zoom", zoomed);
        var slider = d3.select("#sliderdiv").append("div").append("input").style("left", "1000px")
          .attr('id','slider')
          .datum([content.id])
          .attr("type", "range")
          .attr("value", zoom.scaleExtent()[0])
          .attr("min", zoom.scaleExtent()[0])
          .attr("max", zoom.scaleExtent()[1])
          .attr("step", (zoom.scaleExtent()[1] - zoom.scaleExtent()[0]) / 100)
          .on("input", function(d){return slided(d)});

        function zoomed() {
          console.log(d3.event.transform)
          const currentTransform = d3.event.transform;
          d3.select('#'+content.id).attr("transform", 'scale('+currentTransform.k+')');
          slider.property("value", currentTransform.k);
        }

        function slided(d) {

          zoom.scaleTo(d3.select(d), d3.select('#slider').property("value"));
        }
      }



      this.innerSVG = this.svg.append("svg")
        //.attr("width", width + margin.left + margin.right)
        //.attr("height", height + margin.top + margin.bottom)
        .attr("overflow", "visible")
        .append("g")
      this.width = width
    }

    makearea(j, showvol,showpit) {
      let xScale = this.xScale, yScale = this.yScale, yScale2 = this.yScale2, linespacing = this.linespacing
      var area

      area = d3.area()
        .defined(function(d) { return d[1]; })
        .x(function (d, i) {
          return xScale(d[0]);
        })
        .y1(function (d, i) {
          return  +yScale(d[2])*showvol-yScale2(d[1])*showpit + linespacing * j-2;
        })
        .y0(function (d, i) {
          return  -yScale(d[2])*showvol-yScale2(d[1])*showpit+linespacing * j-2  + 1.5*(showvol==false)*(showpit==true);
        })
        .curve(d3.curveMonotoneX);


      return area
    }

    makearea2(j,w) {
      let xScale = this.xScale, yScale = this.yScale, linespacing = this.linespacing
      var area
      area = d3.area()
        .defined(function(d) { return d[1]; })
        .x(function (d, i) {
          return xScale(d[0]);
        })
        .y1(function (d, i) {
          return  -1*yScale(d[2])+ linespacing * j-w;
        })
        .y0(function (d, i) {
          return  linespacing * j -w;
        })
        .curve(d3.curveMonotoneX);


      return area
    }

    make_plot(data_array, amp,params,player){
     // console.log(window.performance.now()-this.t)
      function mouseClick(player,start,k,name, nameid) {
        let viz = Function("return " + name)()

        //player.seekTo(20, true)
        //console.log(k, start)
        if (player.getPlayerState() == 1){
          player.pauseVideo()
          d3.selectAll('#pointer').transition()
          return
        }

        d3.event.preventDefault();
        const mouse = d3.mouse(d3.event.target);
        const [
          xCoord,
          yCoord,
        ] = mouse;

        const mouseY = 0

        const mouseX = +start + viz.xScale.invert(xCoord)
        player.loadVideoById(links[names.indexOf(nameid)],mouseX)


        const bisectDat = d3.bisector(d => d).right;

        const xIndex = bisectDat(amp.t, mouseX, 1);

        // console.log(mouseX)

        let dot = viz.innerSVG.selectAll('.hoverPoint')
          .attr('cx', xCoord)
          .attr('cy', yCoord)
          .attr('r', '1')
          .attr('fill', '#54faff')
          .attr('stroke', 'black')
          .attr('stroke-width', 0.1)
        /*console.log( dot)
                  dot.attr('cx', xCoord)
                  .attr('cy', yCoord)
                  .attr('r', '7')
                  .attr('fill', '#54faff')
                  .attr('stroke', 'black')
                ;*/


        viz.svg.append('rect').classed('movingPoint', true);
        let starts = viz.starts
        let ends = viz.ends
        l = starts.findIndex(element => element >= mouseX)
        k = mouseX - viz.starts[l - 1]

        /*dot = viz0.svg.selectAll('.movingPoint')
          .attr('cx', viz0.xScale(k))
          .attr('cy', (l - 1) * viz0.linespacing)
          .attr('r', '7')
          .attr('fill', '#ee0059')
          .attr('stroke', 'black')*/


        let w = 1
        let rect = viz.svg.selectAll('.movingPoint')
          .attr('id','pointer')
          .attr('x', viz.xScale(k)-w)
          .attr('y', (l - 1) * viz.linespacing)
          .attr('width', w)
          .attr('height', viz.linespacing )//80)
          //.attr('stroke', 'black')
          .attr('fill', '#962a2a');


        /*let duration = 0
        let delay = 0
        duration = viz.ends[l - 1] - viz.starts[l-1] - k


        rect.transition().ease(d3.easeLinear)
          .duration(duration *1000).delay(delay)
          .attr('x', (viz.xScale(viz.ends[l - 1]- viz.starts[l-1])))
          .attr('y', (l-1) * viz.linespacing-w)

          rec.transition().ease(d3.easeLinear)
            .duration(duration*1000).delay(delay)
            .attr('x', (viz0.xScale(viz0.ends[l - 1]- viz0.starts[l-1] )))
            .attr('y', ( l-1) * viz0.linespacing-w)

          delay = delay + duration*1000
          rec.transition().ease(d3.easeLinear)
            .duration(20).delay(delay)
            .attr('x', (viz0.xScale(0)))
            .attr('y', (l) * viz0.linespacing-w)

          delay = delay + 20
          duration = viz0.ends[l] - viz0.starts[l]*/

        let delay = 0
        let duration = viz.ends[l - 1] - viz.starts[l-1] - k
        for (let i = l; i < viz.n_lines; i++) {
          console.log(viz.ends[i - 1]- viz.starts[i-1], viz.xScale(viz.ends[i - 1]- viz.starts[i-1] ))

          rect.transition().ease(d3.easeLinear)
            .duration(duration*1000+300).delay(delay)
            .attr('x', (viz.xScale(viz.ends[i - 1]- viz.starts[i-1] )))
            .attr('y', ( i-1) * viz.linespacing)

          delay = delay + duration*1000
          rect.transition().ease(d3.easeLinear)
            .duration(20).delay(delay)
            .attr('x', (viz.xScale(0)))
            .attr('y', (i) * viz.linespacing)

          duration = viz.ends[i] - viz.starts[i]
          delay = delay + 20

        }








      }

      this.starts = []
      this.ends = []
      let n = this.n
      let t_words = this.params.num_words

      const zip2 = (a, b,c) => a.map((k, i) => [k, b[i],c[i]]);


      var lineheight = 0
      var j = 0
      var k = 0
      var p =0
      var q =0
      var l =0
      var m = 0
      var mt = 0
      var area, area_amp
      const getColumns = (arr, indices) => arr.map(row => indices.map(i => row[i]));





      if(this.params.cmap ==true){
        let pitmean = d3.mean(amp.pit)
        let pitstd = d3.deviation(amp.pit)
        let pmin = pitmean - 3*pitstd
        let pmax = pitmean + 3*pitstd
        console.log(pmin,pmax)
        var colors = ['#053061','#2166ac','#4393c3','#92c5de',
          '#d1e5f0','#f7f7f7','#fddbc7','#f4a582',
          '#e06a59','#c93461','#be223f']
        var pitrange = [0, 0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9, 1.0] .map(x => x * (pmax-pmin)+pmin)
      }else{
        let pmin = 55
        let pmax = 340

        var colors = [ '#307264', '#50897c' ,'#6fa194' ,'#c8d4c8',
          '#d2d6c9' ,'#dcd7ca' ,'#d8cbb9','#ddbfa9'
          ,'#dba788' , '#ce8264', '#b1684c'];
        var pitrange = [0, 0.05,0.1, 0.2, 0.3, 0.35, 0.4, 0.6, 0.7,0.85,  1.0] .map(x => x * (pmax-pmin)+pmin)
      }
      /*var colors = ['#f8e4a3', '#fce276', '#ddf68b', '#99e9e2',
        '#91afd2', '#7e7fb3', '#666ab9', '#886198']*/
      /*['#4a6e9d', '#55809a', '#5d9297',  '#64a493',
      '#69b78f', '#92c898', '#b7daa0', '#dbeba9',
      '#fffdb2', '#ffffce']*/


      /*      var colors = ['#12594c', '#3f7163', '#64897b', '#88a295',
              '#9aafa1', '#adbcae','#c8d4c8','#d2d6c9','#d2d6c9' ,
              '#dcd7ca','#d8cbb9','#ddbfa9' ,'#dba788' ,
              '#ce8264', '#bf7558', '#b1684c',];
            var pitrange = [0, 0.05, 0.1, 0.15,
              0.2, 0.25, 0.3, 0.32,
              0.35, 0.4, 0.45, 0.75,
              0.9, 0.95, 1.0] .map(x => x * 270+60)*/
      var getcolor =  d3.scaleLinear()
        .domain(pitrange)
        .range(colors).interpolate(d3.interpolateHcl)

      var get_clr = function (value, range){
        let clr = colors[range.findIndex(element => element > value)]
        return clr
      }
      var get_binned = function (value, range){
        let val = range.findIndex(element => element > value)
        return val
      }


      let data = zip2(amp.t,this.pitch,this.amplitude)
      //console.log(window.performance.now()-this.t)
      for (let i = 0; i < this.n_print; i++) {
        //console.log(window.performance.now()-this.t)
        var meanval, pltarr, clr, maxv, ymax, a, pltmean, pltstd

        if ( (+data_array.end[i] - data_array.start[m] >=t_words)*(!params.pltint*!params.pltphrase)|| i == n-1  || (data_array.space[i-1]>=params.phrasespacing)|| (data_array.speed[i-1]<=params.speed)*params.pltint) {

          area = this.makearea(lineheight+1,params.showvol,params.showpit)
          area_amp = this.makearea2(lineheight+1,10)
          q = amp.t.findIndex(element => element > parseFloat(data_array.start[j]))
          p = amp.t.findIndex(element => element > parseFloat(data_array.end[i-1]));
          k = data_array.start[j]
          mt = data_array.start[m]
          l = data_array.end[i-1]
          pltarr = [[k - 0.001, data[q][1],data[q][2]]].concat(data.slice(q, p))
          pltarr[p-q + 1] = [+l + 0.01, data[p-1][1],data[p-1][2]]
          pltarr = pltarr.map(function (value) {
            //if (value[1]==''){
            //  value[1] = meanval
            //}
            return [value[0] - mt, value[1],value[2]];
          });
          //if (params.ofs == true){pltarr = pltarr.map(function (value) {return [value[0], value[1]-meanval,value[2]]});ymax = 45}else{ymax = 280}

          // a = this.yScale2(math.max(pltarr[1]))

          //if (pltarr.length <=2){maxv = 0}else{maxv = math.max(pltarr[2])}
          if (this.params.gradient == true){
            var ofs = []
            var clr_val = []
            var test = []

            for (let z = 0; z <= p-q+1; z++){

              ofs = pltarr[z][0] - pltarr[0][0]

              clr_val[z] = {offset: this.xScale(ofs)/this.xScale(pltarr[p-q+1][0]- pltarr[0][0])*100+'%',color: getcolor(pltarr[z][1])}

            }




            this.yScale2 = d3.scaleLog()
              //.domain([pltmean - 2*pltstd, pltmean+2*pltstd]) // input
              .domain([60,360]) // input
              .range([0, this.params.curve]);

            this.innerSVG.append("linearGradient")
              .attr("id", "line-gradient_"+ this.name+String(j))
              .attr("gradientUnits", "userSpaceOnUse")
              //.attr("angle", "180deg")
              .attr("x1", this.xScale(pltarr[0][0]))
              .attr("x2", this.xScale(pltarr[p-q+1][0]))
              //.attr("y1", -150)
              //.attr("y2", 100)
              .attr("y1", "0%")
              .attr("y2", "0%")
              .selectAll("stop")
              .data(clr_val)
              .enter().append("stop")
              .attr("offset", function (d) {
                return d.offset;
              })
              .attr("stop-color", function (d) {
                return d.color;
              });

/////////////test
            var x = this.xScale


            // Add Y axis
            let curve = this.params.ampcurve
            var y = this.yScale2
            var linespacing = this.linespacing



////////////////////

          }
          //console.log((-yScale2(350)-yScale(0.5))/2+linespacing * lineheight-17, 5 + linespacing * lineheight-20, lineheight)
          this.innerSVG.append('circle').classed('hoverPoint', true);
          //let mouseMove
          //if (this.id==0){mouseMove = mouseMove0}else{mouseMove = mouseMove1}

          /*this.innerSVG.append('path')
            .attr('class', 'area')
            .attr("id", "curveshow"+lineheight)
            .datum(pltarr)
            //.attr('fill', '#B0C4DE')
            .attr('fill', "url(#line-gradient"+String(j)+")")
            .attr("stroke", "url(#line-gradient"+String(j)+")" )
            // .attr('stroke', 'black')
            //.attr("stroke-width", 0.2)
            .attr('opacity', this.params.curveopacity)
            .attr('d', area)
            .datum([mt,lineheight])
            .on('click', function (d){mouseMove(player, d[0],d[1])})*/


          let name = Function("return " + 'params.name'+this.id)()
          let w = 10
          // console.log(meanamp)
          //pitch curve

          this.innerSVG.append('rect')
            .attr("id", "rect"+lineheight)
            .attr('x', this.xScale(pltarr[0][0]))
            .attr('y', (lineheight)*linespacing)
            .attr('width', this.xScale(pltarr[p-q+1][0] - pltarr[0][0]) )
            //.attr('height', this.linespacing*meanamp*3)
            //.attr("pointer-events", "visibleStroke")
            .attr('height', this.linespacing-w)
            //.attr("stroke-width", this.params.border*(meanamp*15)**3 )
            .attr('fill', "url(#line-gradient_"+ this.name+String(j)+")")
            .attr("stroke", "black" )
            .attr("stroke-width", 0.4 )
            .attr('opacity',1)
            .datum([mt,lineheight, pltarr,this.name, name])
            .on('click', function (d){mouseClick(player, d[0],d[1],d[3],d[4])})
          //
          //.on('click', function (d){make_curve(d[1]);})//mouseMove(player, d[0],d[1])})
          //ampcurve
          this.innerSVG.append('path')
            .attr('class', 'area')
            .attr("id", "ampcurve"+lineheight)
            .datum(pltarr)
            .attr('fill', '#000000')
            // .attr('stroke', 'black')
            //.attr("stroke-width", 0.2)
            .attr('opacity', 1)
            .attr('d', area_amp)
          //.datum([mt,lineheight])
          //.on('click', function (d){mouseClick(player, d[0],d[1])})

          this.opacity = 0
          //pitch+amp curve
          //console.log(pltarr)
          /*this.innerSVG.append('path')
            .attr('class', 'area')
            .attr("id", "curveshow"+lineheight)
            .datum(pltarr)
            //.attr('fill', '#B0C4DE')
            .attr('fill', "url(#line-gradient"+String(j)+")")
            .attr("stroke", "url(#line-gradient"+String(j)+")" )
            // .attr('stroke', 'black')
            //.attr("stroke-width", 0.2)
            .attr('opacity', this.params.curveopacity)
            .attr('d', area)
            //.datum([mt,lineheight])
            //.on('click', function (d){mouseMove(player, d[0],d[1])})*/


//white rect

          this.innerSVG.append('rect')
            .attr('x', this.xScale(pltarr[p-q+1][0]))
            .attr('y', (lineheight)*linespacing)
            .attr('width', this.xScale(data_array.space[i-1]))
            //.attr('height', this.linespacing*meanamp*3)
            .attr('height', this.linespacing - w)
            .attr("stroke-width", 0.05)
            .attr('stroke', 'black')
            .attr('fill', 'white')
            .attr('opacity', 1);
          if ((data_array.speed[i-1]<params.speed)*params.pltint){
            this.innerSVG.append('rect')
              .attr('x', 4*w+this.xScale(pltarr[p-q+1][0]))
              .attr('y', (lineheight)*linespacing )
              .attr('width', 1)
              //.attr('height', this.linespacing*meanamp*3)
              .attr('height', this.linespacing -w)
              .attr("stroke-width", 0.3)
              .attr('stroke', 'rgb(8,39,86)')
              .attr('fill', 'rgb(8,39,86)')
              .attr('opacity', 1);
          }



          function make_curve(id){

            d3.selectAll("#rect"+id).transition().ease(d3.easeLinear)
              .duration(20000).attr('opacity', 0)
            d3.selectAll("#ampcurve"+id).transition().ease(d3.easeLinear)
              .duration(2000).attr('opacity', 0)
            d3.selectAll("#curve"+id).transition().ease(d3.easeLinear)
              .duration(2000).attr('opacity', 1)


          }
          //this.innerSVG.append('circle').classed('hoverPoint2', true);


          //innerSVG.append("text").classed('hoverText', true);

          //innerSVG.datum(lineheight).on('mouseover', function(d) {this.lineheight = lineheight;console.log(innerSVG.selectAll("curveshow"+lineheight)),mouseMove(player, lineheight,data_array.start[j])})


          //if (data_array.timeloc[i] - data_array.timeloc[j] > t_words || i == n || data_array.space[i-1]>params.phrasespacing){}

          if ( (+data_array.end[i] - data_array.start[m] >= t_words)*(!this.params.pltint )|| (this.params.pltphrase==true)*(!this.params.pltint ) || (data_array.speed[i-1]<=params.speed)*params.pltint || (data_array.space[i-1]>=params.phrasespacing)*params.pltphrase){
            this.starts.push(data_array.start[m])
            this.ends.push(+data_array.end[i-1]+parseFloat(data_array.space[i-1]))
            // console.log(this.ends)
            /*if (data_array.space[i]>params.phrasespacing){
              this.ends.push(data_array.timeloc[i]+data_array.space[i-1])
            }else {
              this.ends.push(data_array.timeloc[i])
            }*/
            lineheight++
            m = i
          }
          j = i

          //console.log(amp.t[q],amp.t[p])


        }
        //if (params.pltphrase==true){lineheight++}

        this.n_lines = lineheight

      }
      //console.log(window.performance.now()-this.t)
      //console.log('END')

    }

    make_text(data_array, amp,params){
      this.svg.append("text")
        .attr("id", `textshow`)
        .attr("text-anchor", "middle")
        .attr("x", (this.xScale(this.params.num_words/2)))
        .attr("y", -11)
        .attr("font-size", 1.2+ "em")
        .attr("dy", .35 + "em")
        .attr("vertical-align", "middle")
        .attr('fill','black')
        .attr('stroke', 'white')
        .attr("stroke-width", 0.1)
        //.attr("fill", speaker_colors[data_array.speaker[i]])
        .attr("font-family", "Avenir Next")
        .attr("font-weight", 500)
        .text(this.title);


      let n = this.n
      let t_words = this.params.num_words
      const widthoffset = 50;
      const linespacing = this.linespacing;
      const xscaleoffset = 100;
      let lineheight = 0
      let k = 0
      let j=0

      for (let i = 0; i <this.n_print-1; i++) {
        if ( (+data_array.end[i] - data_array.start[j] >= t_words)*(!this.params.pltint )|| (this.params.pltphrase==true)*(!this.params.pltint ) || (data_array.speed[i-1]<=params.speed)*params.pltint || (data_array.space[i-1]>=params.phrasespacing)*params.pltphrase){
          // if ( (data_array.timeloc[i] - data_array.timeloc[j] > t_words)*(!params.pltphrase) || i == n-1  || (data_array.space[i-1]>params.phrasespacing)*params.pltphrase){

          j = i
          lineheight++
        }

        //if (params.pltphrase==true||data_array.space[i]>params.phrasespacing){lineheight++; k = word_loc[i]}

        this.svg.append("text")
          .attr("id", `textshow`)
          .attr("text-anchor", "middle")
          .attr("x", (this.xScale(data_array.timeloc[i] - data_array.start[j] )))
          .attr("y", (linespacing) * (lineheight+1)-7)
          .attr("font-size", this.params.font/8+ "em")
          .attr("dy", .35 + "em")
          .attr("vertical-align", "middle")
          .attr('fill','black')
          //.attr("fill", speaker_colors[data_array.speaker[i]])
          .attr("font-family", "Avenir Next")
          //.attr("font-weight", 500)
          //.attr("letter-spacing",  duration[i]-0.2+"px")
          //.attr("letter-spacing",  this.xScale(data_array.duration[i]/3)+"px")
          .text(data_array.words[i]);
      }
    }

    make_scatter(data, offs){
      const zip = (a, b) => a.map((k, i) => [k, b[i]]);
      let width = 300
      let height = 300
      let data_plot = zip (data.amp, data.pit)
      // Add X axis
      var x = d3.scaleLinear()
        .domain([-0.0, d3.extent(data.amp)[1]])
        .range([ 0, width ]);
      this.svg.append("g")
        .attr('id','showstats')
        .attr("transform", "translate("+(width+offs)+"," + height + ")")
        .call(d3.axisBottom(x).ticks(5));

      // Add Y axis
      var y = d3.scaleLinear()
        .domain([50, 350])
        .range([ height, 0]);
      this.svg.append("g")
        .attr('id','showstats')
        .attr("transform", "translate("+(width+offs)+"," + 0 + ")")
        .call(d3.axisLeft(y).ticks(5));

      this.svg.append('g')
        .attr('id','showstats')
        .attr("transform", "translate("+(width+offs)+"," + 0 + ")")
        .selectAll("dot")
        .data(data_plot)
        .enter()
        .append("circle")
        .attr("cx", function (d) { return x(d[0])} )
        .attr("cy", function (d) { return y(d[1])} )
        //.attr("cx", function (d) { console.log(d);if (d[1] = '') {return 0}else{return x(d[1]);} } )
        //.attr("cy", function (d) { if (d[2] = '') {return 0}else{return y(d[2]);} } )
        .attr("r", 3)
        .attr('opacity',0.25)
        .style("fill", "#69a5b3")
      this.svg.append("text")
        .attr('id','showstats')
        .attr("y", height/2-10)
        .attr("x",offs+width-50)
        .style("text-anchor", "middle")
        .attr("dy", "1em")
        .text("Pitch");

      this.svg.append("text")
        .attr('id','showstats')
        //.attr("transform", "rotate(-90)")
        .attr("y", height+20)
        .attr("x", offs + width*1.5)
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Amplitude");




    }

    make_hist(data, offs, label,clr, ext){
      console.log(d3.extent(data))
      let width = 300
      let height = 300
      // X axis: scale and draw:
      var x = d3.scaleLinear()
        .domain(ext)     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
        .range([0, width]);
      this.svg.append("g")
        .attr('id','showstats')
        .attr("transform", "translate("+(width+offs)+"," + height + ")")
        .call(d3.axisBottom(x).ticks(7));

      // set the parameters for the histogram
      var histogram = d3.histogram()
        .value(function(d) { return d })   // I need to give the vector of value
        .domain(x.domain())  // then the domain of the graphic
        .thresholds(x.ticks(20)); // then the numbers of bins

      // And apply this function to data to get the bins
      var bins = histogram(data);

      // Y axis: scale and draw:
      var y = d3.scaleLinear()
        .range([height, 0]);
      y.domain([0, d3.max(bins, function(d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
      this.svg.append("g")
        .attr('id','showstats')
        .attr("transform", "translate("+(width+offs)+"," + 0 + ")")
        .call(d3.axisLeft(y).ticks(5));

      // append the bar rectangles to the svg element
      this.svg.selectAll("rect2")
        .attr("transform", "translate("+(width+offs)+"," + 0 + ")")
        .data(bins)
        .enter()
        .append("rect")
        .attr("x", 1)
        .attr("transform", function(d) { return "translate(" +(width+offs+ x(d.x0)) + "," + y(d.length) + ")"; })
        .attr("width", function(d) { return x(d.x1) - x(d.x0) -1 ; })
        .attr("height", function(d) { return height - y(d.length); })
        .attr('id','showstats')
        .style("fill", clr)

      this.svg.append("text")
        .attr('id','showstats')
        //.attr("transform", "rotate(-90)")
        .attr("y", height+20)
        .attr("x", offs+width*1.5)
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text(label);

    }

    make_viz(){
      // console.log(this.params.name0)


      this.prep_data(this.amp)
      this.make_svg()
      this.make_scale()


      this.make_plot(this.data_array, this.amp,this.params,this.player)

      //this.make_svg()
      this.make_text(this.data_array, this.amp,this.params)

      if (this.params.showstats == true){
        this.make_scatter(this.amp, 700)
        this.make_hist(this.amp.pit, 1100, "Pitch", "#69b3a5",[60, 300])
        this.make_hist(this.amp.amp, 1500, "Amplitude","#6978b3",[0,0.6])
        this.make_hist(this.data_array.space, 1900, "Pauses","#9e69b3",[0,0.5])
        this.make_hist(this.data_array.speed, 2300, "Speaking Rate","#69b38c",[0,100])
      }

    }







  }


</script>


</body>
</html>
