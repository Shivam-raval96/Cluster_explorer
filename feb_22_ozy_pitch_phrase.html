



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
  <script type="text/javascript" src="dat.gui.min.js"></script>
  <style>
    body {
      overflow: scroll; /* Show scrollbars */
    }

  </style>
  <title> Speech Visualization Demo</title>
</head>
<body>
<p style="font-size:14px;">
  Instructions:</br>
  Press StartVisual to start rendering at default values. Drag a curve to place it anywhere on the screen<br>
  Move the sliders to change the multiplier for background curve height or font size. Show/hide the text with appropriate checkbox.<br>
  Moving average slider computes the sliding average of the signal <br>
  Enter max/min pitch value (in Hz) to change the colormap range. Green: Minimum value, Orange: Maximum value, Grey: no pitch detected.<br>
  Check sub_avg_pitch to subtract avg pitch for each line. Max/Min colormap range -> [-25 , 25]Hz <br>
  Refresh browser  to begin again.<br>
  Pick any two visuals to compare as a single line. Press CompareVisual to show.
</p>
<p></p>
<script>

  /*var words = []
  var time = []
  var space = []
  var amplitude = []*/

  function load_data(path) {
    var data_array = {
      words: [],
      time: [],
      space: [],
      amplitude: [],
      timeloc:[],
    }


    d3.csv(path, function (data) {
      for (var i = 0; i < data.length; i++) {
        data_array.words[i] = data[i].Word
        data_array.time[i] = data[i].std_time_spent
        data_array.space[i] = data[i].post_space
        data_array.amplitude[i] = data[i].amplitude2
        data_array.timeloc[i] = data[i].time
      }
      //console.log(data_array)

    })

    return data_array
  };

  function load_amp(path2) {
    var amp ={
      t:[],
      amp:[],
    }

    d3.csv(path2, function (data) {
      for (var i = 0; i < data.length; i++) {
        amp.t[i] = data[i].time
        amp.amp[i] = data[i].amplitude
      }
    })

    return amp

  }
  function load_pitch(path3) {
    var pit ={
      t:[],
      pit:[],
    }

    d3.csv(path3, function (data) {
      for (var i = 0; i < data.length; i++) {
        pit.t[i] = data[i].time
        pit.pit[i] = data[i].pitch
      }
    })

    return pit

  }


  paths = [
    "csv/ozymandias/Ozymandias - Percy Bysshe Shelley (GCSE Poetry)-(480p).csv",
    "csv/ozymandias/Ozymandias - by Percy Bysshe Shelley (Read by Jack Donovan).csv",
    "csv/ozymandias/Ozymandias by Percy Bysshe Shelley - Poetry Reading.csv",
    "csv/ozymandias/The Ballad of Buster Scruggs - Ozymandias-(480p).csv",
    "csv/ozymandias/Ozymandias.csv",
    "csv/ozymandias/Ozy_adam.csv",
    "csv/ozymandias/ozy_ben_k.csv",
    "csv/ozymandias/Ozy_bryan.csv",
    "csv/ozymandias/ozy_darin_h.csv",
    "csv/ozymandias/ozy_elanor_b.csv",
    "csv/ozymandias/Ozy_john_g.csv",
    "csv/ozymandias/Ozy_r_attenb.csv",
    "csv/ozymandias/Ozy_tom.csv",
    "csv/ozymandias/Ozy1.csv",
    "csv/ozymandias/ozy3.csv",
    "csv/ozymandias/ozy4.csv",
    "csv/ozymandias/ozy5.csv",
  ]

  paths2 = [
    "csv/ozymandias/Ozymandias - Percy Bysshe Shelley (GCSE Poetry)-(480p)_ae.csv",
    "csv/ozymandias/Ozymandias - by Percy Bysshe Shelley (Read by Jack Donovan)_ae.csv",
    "csv/ozymandias/Ozymandias by Percy Bysshe Shelley - Poetry Reading_ae.csv",
    "csv/ozymandias/The Ballad of Buster Scruggs - Ozymandias-(480p)_ae.csv",
    "csv/ozymandias/Ozymandias_ae.csv",
    "csv/ozymandias/Ozy_adam_ae.csv",
    "csv/ozymandias/ozy_ben_k_ae.csv",
    "csv/ozymandias/Ozy_bryan_ae.csv",
    "csv/ozymandias/ozy_darin_h_ae.csv",
    "csv/ozymandias/ozy_elanor_b_ae.csv",
    "csv/ozymandias/Ozy_john_g_ae.csv",
    "csv/ozymandias/Ozy_r_attenb_ae.csv",
    "csv/ozymandias/Ozy_tom_ae.csv",
    "csv/ozymandias/Ozy1_ae.csv",
    "csv/ozymandias/ozy3_ae.csv",
    "csv/ozymandias/ozy4_ae.csv",
    "csv/ozymandias/ozy5_ae.csv",
  ]

  paths3 = [
    "csv/ozymandias/Ozymandias - Percy Bysshe Shelley (GCSE Poetry)-(480p)_p.csv",
    "csv/ozymandias/Ozymandias - by Percy Bysshe Shelley (Read by Jack Donovan)_p.csv",
    "csv/ozymandias/Ozymandias by Percy Bysshe Shelley - Poetry Reading_p.csv",
    "csv/ozymandias/The Ballad of Buster Scruggs - Ozymandias-(480p)_p.csv",
    "csv/ozymandias/Ozymandias_p.csv",
    "csv/ozymandias/Ozy_adam_p.csv",
    "csv/ozymandias/ozy_ben_k_p.csv",
    "csv/ozymandias/Ozy_bryan_p.csv",
    "csv/ozymandias/ozy_darin_h_p.csv",
    "csv/ozymandias/ozy_elanor_b_p.csv",
    "csv/ozymandias/Ozy_john_g_p.csv",
    "csv/ozymandias/Ozy_r_attenb_p.csv",
    "csv/ozymandias/Ozy_tom_p.csv",
    "csv/ozymandias/Ozy1_p.csv",
    "csv/ozymandias/ozy3_p.csv",
    "csv/ozymandias/ozy4_p.csv",
    "csv/ozymandias/ozy5_p.csv",
  ]


  links = ["",
    "",
    "",
    "",
    "",
    "https://drive.google.com/file/d/1Ehrg4jTlurAnAo8je9Y1D0ED6zBZJcCr/view?usp=sharing",
    "https://www.youtube.com/watch?v=krbX-9ugbI4", //benk
    "https://www.youtube.com/watch?v=T3dpghfRBHE", //bryanC
    "https://www.youtube.com/watch?v=HfBcLOrm_Gg",//darin hagre
    "https://www.youtube.com/watch?v=7TgYh9prPqk", //elanor
    "https://www.youtube.com/watch?v=gHsBcUD_7jw", //sir john gielgud
    "https://www.youtube.com/watch?v=bv2nklTyq9Q", //richard a
    "https://www.youtube.com/watch?v=LVTiES1pE2o", // tom o bedlam
    "https://www.youtube.com/watch?v=bFgw_vhwRdA",// rob simpson 1 "https://www.youtube.com/watch?v=V1bbJT7bZVA" ozy2
    "https://drive.google.com/file/d/1ExAJ51adBx6Owf0mC_c40BwoNLTegxlX/view?usp=sharing",//3
    "https://www.youtube.com/watch?v=Tz8VG1zIEL8",// lance foster 4
    "https://youtu.be/ezWk5wTr6sU",//mythbuster 5

  ]

  var data_array = [];
  var amp = [];
  var pit = [];
  for(i=0; i<paths.length; i++){
    data_array[i] = load_data(paths[i])
    amp[i] = load_amp(paths2[i])
    pit[i] = load_pitch(paths3[i])
    //console.log(data_array[i])
  }
  //data_array = load_data(paths[3])

  function make_viz_array(data_array){
    for(i=0; i<data_array.length; i++){
      make_viz(data_array[i],amp[i],pit[i],params,links[i])
    }
  }

  var gui = new dat.GUI({
    height : 5 * 32 - 1
  });

  var params = {
    num_words:15,
    font: 7.5,
    curve: 7,
    curveopacity:1,
    size1:1,
    size2:0.5,
    size3:0.3,
    noisefloor:0.1,
    showtext: true,
    showcurve: true,
    visualize: "Volume",
    curve_color: "#5CA4C4",
    text_color: "#000000",
    n_avg: 3,
    zoomlvl: 0.3,
    panx: 50,
    pany: 50,
    subvizx: 2,
    subvizy: 6,
    links: links,
    pmax:250,
    pmin:60,
    phrasespacing:0.3,
    compare: false,
    c1:1,
    c2:2,
    norm:false,
    //bold_value: 1
  };

  param_default = params

  function clear_svg(num){
    for (i =0; i<num; i++){
      d3.select("svg").remove()
    }
  }


  gui.add(params, 'font').name('Font Size').min(5).max(12).step(0.25).onChange(function(){
    clear_svg(data_array.length)

    make_viz_array(data_array,amp)

  })
  /*gui.add(params, 'noisefloor').name('Noise amp').min(0.001).max(0.015).step(0.001).onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)

  })*/
  gui.add(params, 'curve').name('Curve Height').min(5).max(15).step(0.1).onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  })

  gui.add(params, 'curveopacity').name('Curve Opacity').min(0).max(1).step(0.1).onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  })

  gui.add(params, 'n_avg').name('Moving Average').min(1).max(20).step(1).onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  })

  gui.add(params, 'pmin').name('Pitch min val').onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  })

  gui.add(params, 'pmax').name('Pitch max val').onChange(function(){
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  })

  /*gui.add(params, 'bold_value').name('Boldness').min(0.5).max(10).step(0.5).onChange(function(){
    d3.select("svg").remove()
    make_viz(data_array,params)
  })*/
  gui.add(params, 'showtext').name('Show/Hide Text').listen().onChange(function(){
    // Determine if current line is visible
    var active = textshow.active ? false : true,
      newOpacity = active ? 0 : 1;
    // Hide or show the elements
    d3.selectAll("#textshow").style("opacity", newOpacity);
    // Update whether or not the elements are active
    textshow.active = active;
  });

  gui.add(params, 'norm').name('sub_avg_pitch').listen().onChange(function(){
    if (params.norm){params.pmin=-50;params.pmax=50;
    } else{params.pmin=60;params.pmax=300}
    if (params.compare){params.font=10;params.curve = 20;
    } else{params.font=param_default.font;params.curve = param_default.curve;}


    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
    });

  /*gui.add(params, 'showcurve').name('Show/Hide Curve').listen().onChange(function(){
    // Determine if current line is visible
    var active = curveshow.active ? false : true,
      newOpacity = active ? 0 : params.curveopacity;
    // Hide or show the elements
    d3.selectAll("#curveshow").style("opacity", newOpacity);
    // Update whether or not the elements are active
    curveshow.active = active;
  });*/


  /*gui.addColor(params,'curve_color').name('Curve Color').onChange(function() {
    clear_svg(data_array.length)
    make_viz_array(data_array,amp)
  });*/

  params.startAnimation =
    function() {
      params = param_default
      clear_svg(data_array.length)
      make_viz_array(data_array,amp)
    };

  gui.add(params,'startAnimation').name('StartVisual');

  gui.add(params, 'c1').name('Compare viz 1')
  gui.add(params, 'c2').name('Compare viz 2')

  params.compareAnim =
    function() {
    params.compare=true;
    params.subvizx = 1
      params.subvizy = 10
      params.zoomlvl= 0.15,
      params.font=13;params.curve = 25
      if (params.norm){params.pmin=-25;params.pmax=25;
      } else{params.pmin=60;params.pmax=300}
      clear_svg(data_array.length)
      make_viz(data_array[params.c1-1],amp[params.c1-1],pit[params.c1-1],params,links[params.c1-1],params.c1)
      make_viz(data_array[params.c2-1],amp[params.c2-1],pit[params.c2-1],params,links[params.c2-1],params.c2)
    };
  gui.add(params,'compareAnim').name('CompareVisual');

  /*params.compareAll =
    function() {
      params.compare=true;
      params.subvizx = 1
      params.subvizy = 10
      params.zoomlvl= 0.15,
        params.font=13;params.curve = 25
      if (params.norm){params.pmin=-25;params.pmax=25;
      } else{params.pmin=60;params.pmax=300}
      clear_svg(data_array.length)
      make_viz_array(data_array,amp)
    };
  gui.add(params,'compareAll').name('CompareAll');*/
  /*params.AudioFile =
    function() {
      window.open('https://drive.google.com/file/d/16hHsv2zyuTlAknQX-xpUxQ6d2DCtTbCg/view?usp=sharing');
    };

  gui.add(params,'AudioFile').name('GetAudioFile');*/

  /*params.resetAnimation =
    function() {
      params = param_default
      d3.select("svg").remove()
      make_viz(data_array,params)
    };*/

  //gui.add(params,'resetAnimation').name('Reset');

function make_svg(){
  var svg = d3.select("body").append("svg")
    .attr("width", svgwidth)
    .attr("height", svgheight)
    //.call(zoom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")scale("+params.zoomlvl+")")
}

  function make_viz(data_array,amp,pit,params,link,id=0) {
    //console.log(data_array)
    curveval = params.curve
    font = params.font;
    curvecolor = params.curve_color;
    textcolor = params.text_color;
    opacity = params.curveopacity
    n_avg = params.n_avg
    //boldval = params.bold_value
    words = data_array.words;
    time = data_array.time;
    space = data_array.space;
    word_loc = data_array.timeloc
    //amplitude = data_array.amplitude;
    n = words.length;
    t_words = params.num_words
    t = amp.t
    amplitude = amp.amp
    const widthoffset = 100;
    const linespacing = 70;
    const xscaleoffset = 300;

    /**
     * returns an array with moving average of the input array
     * -------moving average slider cuts off before the end: edges might not be accurate
     * @param array - the input array
     * @param count - the number of elements to include in the moving average calculation
     */
    function movingAvg(array, count) {

      // calculate average for subarray
      var avg = function (subarray) {

        var sum = 0, num = 0, val;
        for (let i = 0; i < subarray.length; i++) {
          val = parseFloat(subarray[i]);
          sum += val;
          num++;
        }
        return sum / num;
      };

      var result = array.slice(0,count-1), val;

      // calculate average for each subarray and add to result
      for (let i = count-1; i < array.length; i++) {



        val = avg(array.slice(i - Math.floor(count/2), i + Math.ceil(count/2)));
        result.push(val);
        //console.log( array.slice(i, i + count) )

      }

      return result;

    }

    //console.log(movingAvg([1,2,5,3,4,1], n_avg))


    quantity = movingAvg(amp.amp, n_avg)


    var margin = {top: 50, right: 50, bottom: 50, left: 50}
      , width = 0.75*(window.innerWidth -widthoffset - margin.left - margin.right)/params.subvizx // Use the window's width
      , height = 2*(window.innerHeight - margin.top - margin.bottom)/params.subvizy; // Use the window's height

    svgwidth = width + margin.left + margin.right
    svgheight = height + margin.top + margin.bottom
if (params.compare){svgheight = 50}
    var xScale = d3.scaleLinear()
      .domain([0, t_words ]) // input
      .range([0, 6*(width - widthoffset + xscaleoffset)]); // output
    var xScale_area = d3.scaleLinear()
      .domain([0, t_words]) // input
      .range([0, 6*(width - widthoffset + xscaleoffset)]); // output

// Y scale input between 0, 1 output in pxls
    var yScale = d3.scaleLinear()
      .domain([0, 0.3]) // input
      .range([0, 2 * curveval]); // output
if (params.compare){
  margin.left = -3*window.innerWidth
  svgwidth = 10*svgwidth
}else{margin.left = -4*margin.left}

    var svg = d3.select("body").append("svg")
      .attr("width", svgwidth)
      .attr("height", svgheight)
      .attr("transform", "translate(" + margin.left  + "," + margin.top + ")scale("+params.zoomlvl+")")
      .call(d3.zoom().on("zoom", function () {
        svg.attr("transform", d3.event.transform)
      }))
      .attr("overflow", "visible")
      .append("g");


    function makearea(j) {
      var area = d3.area()
        .x(function (d, i) {
          return xScale_area(d[0]);
        })
        .y1(function (d, i) {
          return -yScale(d[1]) + linespacing * j-10;
        })
        .y0(function (d, i) {
          return  linespacing * j-10;
        })
        .curve(d3.curveMonotoneX);

      return area
    }





    var innerSVG = svg.append("svg")
      .attr("width", "100%")
      .attr("height","100%")
      .attr("overflow", "visible")
      .append("g")

    const breakwords = ["gland","red","bear","declare","frowned","beth", "fade", "there", "land", "stone", "sand", "frown", "command", "read", "things", "fed", "appear", "kings", "despair", "decay", "bare", "away"];
    const zip = (a, b) => a.map((k, i) => [k, b[i]]);
    data = zip(t,quantity)
    a = 0
    /*for (b = 0; b<= words.length;b++) {
      if (breakwords.includes(words[b- 1]) || b == words.length || space[b]>params.phrasespacing) {
        q = pit.t.findIndex(element => element > parseFloat(word_loc[a]))
        p = pit.t.findIndex(element => element > parseFloat(word_loc[b - 1]))

        avg = math.mean(pit.pit.slice(q,p))
        //a = .map( function(value) {return value - avg});
        console.log(a,b,avg)
        b=a-1
      }

    }*/

    lineheight = 0
    k = 0
    if (params.showbold){
      boldvalue = duration.map(x => x * params.boldval*180*3)
      boldvalue = boldvalue.map(x => x * (x<900)+900*(x>900))
    }else{
      boldvalue = params.boldval*180*3
    }

    for (let i = 0; i <n; i++) {

      if ( (breakwords.includes(words[i-1])  || i == n )&& params.compare == false){
        //console.log(word_loc[i]-word_loc[k])
        k = i
        lineheight++
      }
      //console.log(words[i],words[i].length)
      svg.append("text")
        .attr("id", `textshow`)
        .attr("text-anchor", "middle")
        .attr("x", (xScale((word_loc[i]-word_loc[k]))))
        .attr("y", linespacing * lineheight)
        .attr("font-size", font/5 + "em")
        .attr("dy", .35 + "em")
        .attr("vertical-align", "middle")
        //.attr("fill", speaker_colors[data_array.speaker[i]])
        //.attr("font-family", "Avenir Next")
        //.attr("font-weight", boldvalue[i])
        .attr("letter-spacing",  20*time[i]+"px")
        .text(words[i]);
    }

    lineheight = 0
    j = 0
    k = 0
    const noise = params.noisefloor
    const getColumns = (arr, indices) => arr.map(row => indices.map(i => row[i]));
    function notNoise(x) {
      return x > noise;
    }



    for (let i = 0; i <= n; i++) {
      //console.log(data[t.length][0])






      if ( breakwords.includes(words[i-1])  || i == n ){

          l = t.findIndex(element => element > parseFloat(word_loc[j]))
          k = t.findIndex(element => element > parseFloat(word_loc[i-1]));
          //console.log(t[l],t[k],word_loc[j], word_loc[i-1] )
          area = makearea(lineheight)
          dat = data.slice(l, k)
          meanval = math.mean(getColumns(dat, [1]).filter(notNoise))

        pltarr = [[t[l] - 0.1, data[l][1]]].concat(dat)
        pltarr[pltarr.length] = [+data[k][0] + 0.1, data[k][1]]
        pltarr = pltarr.map(function (value) {
            if(value[1]<noise){
            value[1] = 0
          }
            return [value[0] - t[l], value[1]];
          });

        arr = [1,2,3,0.3,0.05]



          q = pit.t.findIndex(element => element > parseFloat(word_loc[j]))
          p = pit.t.findIndex(element => element > parseFloat(word_loc[i - 1]))
          //console.log(q,p)
        function countNonEmpty(array) {
          return array.filter(Boolean).length;
        }

          pltpit_x = pit.t.slice(q, p)

          pltpit_y = pit.pit.slice(q, p)

          if (params.norm){avg = math.sum(pltpit_y)/countNonEmpty(pltpit_y)}else{avg=0}

          //console.log(avg)

          //pltpit_y_avg = pltpit_y.map(function (value){ return value - avg})
          pltpit_x = pltpit_x.map(function (value) {
            return value - pit.t[q];
          });


        if (params.compare){
          //console.log(j)
          pltarr = [[t[l] - 0.1, data[l][1]]].concat(data.slice(l, data.length))
          pltarr = pltarr.map(function (value) {
            if(value[1]<noise){
            value[1] = 0
          }
            return [value[0] - t[l], value[1]];
          });
          pltpit_x = pit.t.slice(q, pit.t.length)
          pltpit_y = pit.pit.slice(q, pit.pit.length)

          if (params.norm){avg = math.sum(pltpit_y)/countNonEmpty(pltpit_y)}else{avg=0}


          //pltpit_y_avg = pltpit_y.map(function (value){ return value - avg})
          pltpit_x = pltpit_x.map(function (value) {
            return value - pit.t[q];
          });
        }


          p1 = params.pmin + 3 * (params.pmax - params.pmin) / 4
          p2 = params.pmin + (params.pmax - params.pmin) / 2
          p3 = params.pmin + (params.pmax - params.pmin) / 3
          p4 = params.pmin + (params.pmax - params.pmin) / 4
          //console.log(p1,p2,p3,p4)
          var myColor = d3.scaleLinear().domain([params.pmax, p1, p2, p3, p4, params.pmin])
            .range(["rgba(199,117,96,255)", "rgba(219,167,136,1)", "rgba(239,219,203,1)", "rgba(179,208,199,1)", "rgba(111,161,148,1)", "rgba(48,114,100,1)"])

//console.log(myColor(100))

          var ofs = []
          var data11 = []
          //mean = math.mean(pltpit_y)
          //std = math.std(pltpit_y)
          for (let z = 0; z < pltpit_y.length; z++) {
            if (pltpit_y[z] == "") {
              opa = 0.2
              clr = "rgba(100,100,100,0.5)"
            } else {
              //opa = (pltpit_y[z] - mean) / (2 * std) + 0.3
              clr = String(myColor(pltpit_y[z]-avg))
              //console.log(pltpit_y[z]-avg)
            }
            ofs = pltpit_x[z] / pltpit_x[pltpit_x.length-1]
            data11[z] = {offset: ofs * 100 + "%", color: clr}
            //data11[z] = {offset: ofs*100+"%",color: "rgba(0,80,100,"+opa+")"}
            //data11[z] = {offset: ofs*100+"%",color: "hsl(192,"+opa*100+"%, 50%)"}
            //
            //console.log(pltpit_y[z],opa)
          }
        //console.log(pltpit_y)
          if (params.compare){lg = id}else{lg = i}
          innerSVG.append("linearGradient")
            .attr("id", "line-gradient" + String(lg))
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", xScale(0))
            .attr("y1", -yScale(0.5) + linespacing * j-10)
            .attr("x2", xScale(pltpit_x[pltpit_x.length-1]))
            .attr("y2",  -yScale(0)+ linespacing * j-10)
            .selectAll("stop")
            .data(data11)
            .enter().append("stop")
            .attr("offset", function (d) {
              return d.offset;
            })
            .attr("stop-color", function (d) {
              return d.color;
            });


          //console.log(pltarr)
          //console.log(grp_data)
          innerSVG.append('path')
            .attr('class', 'area')
            .attr("id", "curveshow")
            .datum(pltarr)
            //.attr('fill', params.curve_color)
            .attr('opacity', params.curveopacity)
            .attr('fill', "url(#line-gradient" + String(lg) + ")")
            .attr("stroke", "url(#line-gradient" + String(lg) + ")")
            //.attr('stroke','black')
            //.attr("stroke-width", 0.2)
            .attr('d', area);
          /*innerSVG.append('path')
          .attr('class', 'area')
          .attr("id", "curveshow")
          .datum(pltarr2)
          .attr('fill', params.curve_color)
          .attr('opacity', params.curveopacity2)
          .attr('d', area);
        innerSVG.append('path')
          .attr('class', 'area')
          .attr("id", "curveshow")
          .datum(pltarr3)
          .attr('fill', params.curve_color)
          .attr('opacity', params.curveopacity3)
          //.attr('stroke','black')
          //.attr("stroke-width", 0.2)
          .attr('d', area);
        innerSVG.append('path')
          .attr('class', 'area')
          .attr("id", "curveshow")
          .datum(pltarr4)
          .attr('fill', params.curve_color)
          .attr('opacity', 0.6*params.curveopacity)
          //.attr('stroke','black')
          //.attr("stroke-width", 0.2)
          .attr('d', area);*/




        if (params.compare==false ) {
          j = i
          lineheight++
        }else{break}
        }
      }

    /*svg.append("text")
      .attr("id", `audiolink`)
      .attr("text-anchor", "middle")
      .attr("x", (xScale(2)))
      .attr("y", -100)
      .attr("font-size", "4em")
      .attr("dy", .35 + "em")
      .attr("vertical-align", "middle")
      .on("click", function() { window.open("https://www.random.com/" + d ); })
      //.attr("fill", speaker_colors[data_array.speaker[i]])
      //.attr("font-family", "Avenir Next")
      //.attr("font-weight", boldvalue[i])
      .text("Audio")*/

    if (params.compare==false) {
      svg.append("a")
        .attr("xlink:href", link)
        .attr("target", "_blank")
        .append("text")
        .attr("text-anchor", "middle")
        .attr("x", xScale(2))
        .attr("font-size", "3em")
        .attr("dy", -1.5 + "em")
        .attr("vertical-align", "middle")
        .attr("fill", 'darkred')
        .text("Video Link")
    }


  }
  /*
  function linspace(start, stop, num, endpoint = true) {
    const div = endpoint ? (num - 1) : num;
    const step = (stop - start) / div;
    return Array.from({length: num}, (_, i) => start + step * i);
  }
   */

</script>


<script>
  function compare(data_array1,data_array2) {

  }
</script>
</body>
</html>

