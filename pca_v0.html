<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="js/pca.min.js"></script>
  <script src="js/papaparse.min.js"></script>

  <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
  <script src="https://cdn.jsdelivr.net/npm/danfojs@1.1.0/lib/bundle.min.js"></script>
  <script src="https://unpkg.com/@saehrimnir/druidjs"></script>
  <script src="lodash.js"></script>


  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <style>

    text {
      font-family: sans-serif;
      fill: #000000;
    }

    table {
      visibility: hidden;
      position: absolute;
      top: 30px;
      left: 500px;
      font-family: sans-serif;
      font-size: 0.7em;
    }

    tr:nth-child(even) {
      background-color: #d9d9d9;
    }

    .brushed {
      fill: #ff3399;
      stroke: #8e1b54;
      opacity: 1.0;
    }

    .non_brushed {
      fill: #404040;
      opacity: 0.5;
    }


     .active {
       fill: #ff3399;
       stroke: #000;
       opacity: 1.0;
       stroke-width: 4px;
     }

  </style>

</head>
<body>
<h2> Dynamic PCA</h2>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>
<script>
  //var data = [[40,50,60],[50,70,60],[80,70,90],[50,60,80]];


  async function doStuff(data) {

    function addArrays(ar1, ar2){
      var ar3 = [];
      for(var i in ar1)
        ar3.push(ar1[i] + ar2[i]);
      return ar3;
    }

    const getColumns = (arr, indices) => arr.map(row => indices.map(i => row[i]));
    //Data is usable here
    let df = new dfd.DataFrame(data)
    //df.print()

    let scaler = new dfd.StandardScaler()
    scaler.fit(df)

    let df_enc = scaler.transform(df)

    data2 = df_enc.$data
    var vectors = PCA.getEigenVectors(data2);

    var adData = PCA.computeAdjustedData(data2,vectors[0], vectors[1])

    var compressed = adData.formattedAdjustedData;


    //var uncompressed = PCA.computeOriginalData(d3.transpose(compressed)[0],adData.selectedVectors,adData.avgData);

//console.log(d3.transpose(compressed)[0])

    // Add X axis
    var x = d3.scaleLinear()
      .domain(d3.extent(compressed[0]))
      .range([ 0, width ]);

    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.zoom().on("zoom", function () {
        svg.attr("transform", d3.event.transform)
      }))
      .call(d3.axisBottom(x));

    // Add Y axis
    var y = d3.scaleLinear()
      .domain(d3.extent(compressed[1]))
      .range([ 0, height]);
    svg.append("g")
      .call(d3.axisLeft(y));

    let drag = d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended);











    // Add dots
    compressed_to_plot= d3.transpose(compressed)

    var dots = svg.append('g')
      .selectAll("dot")
      .data(compressed_to_plot) // the .filter part is just to keep a few dots on the chart, not all of them
      .enter()
      .append("circle")
      .attr("cx", function (d) { return x(d[0]); } )
      .attr("cy", function (d) { return y(d[1]); } )
      .attr("r", 7)
      .style("fill", "#69b3a2")
      .style("opacity", 0.3)
      .on("mouseover", mouseover )
      .on("mousemove", function(d){return mousemove(d, adData.selectedVectors)})
      .on("mouseleave", mouseleave )
      .call(drag)
      //.style("stroke", "white")
      //.call(brush)
      //.attr("class", "non_brushed");

    function dragstarted(d) {
      d3.select(this).raise().classed('active', true);
    }

    function dragged(d, vec) {


      d[0] = x.invert(d3.event.x);
      d[1] = y.invert(d3.event.y);
      d3.select(this)
        .attr('cx', x(d[0]))
        .attr('cy', y(d[1]))

      tooltip
        .html("PCA components: " +d[0].toFixed(2) +" "+ d[1].toFixed(2)+"<br>"+"Reconstructed components: " +"Calculating")
        .style("left", (d[0]+90) + "px")
        .style("top", (d[1]) + "px")





    }

    function dragended(d) {
      d3.select(this).classed('active', false);
    }


  }

  // A function that change this tooltip when the user hover a point.
  // Its opacity is set to 1: we can now see it. Plus it set the text and position of tooltip depending on the datapoint (d)
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
  }

   function mousemove (d,vec) {
   var unc1 = PCA.scale(vec, d[0] )[0];
   var unc2 = PCA.scale(vec, d[1] )[1];


     var unc = [];
     var plt = 0
     for(var i in unc1){
       unc.push(unc1[i] + unc2[i]);
       var plt = plt + " " + unc[i].toFixed(2)}



    tooltip
      .html("PCA components: " +d[0].toFixed(2) +" "+ d[1].toFixed(2)+"<br>"+"Reconstructed components: " +plt.replace('0',''))
      .style("left", (d[0]+90) + "px") // It is important to put the +90: other wise the tooltip is exactly where the point is an it creates a weird effect
      .style("top", (d[1]) + "px")
  }

  // A function that change this tooltip when the leaves a point: just need to set opacity to 0 again
  var mouseleave = function(d) {
    tooltip
      .transition()
      .duration(200)
      .style("opacity", 0)
  }


  function highlightBrushedCircles() {

    if (d3.event.selection != null) {

      // revert circles to initial style
      circles.attr("class", "non_brushed");

      var brush_coords = d3.brushSelection(this);

      // style brushed circles
      circles.filter(function (){

        var cx = d3.select(this).attr("cx"),
          cy = d3.select(this).attr("cy");

        return isBrushed(brush_coords, cx, cy);
      })
        .attr("class", "brushed");
    }
  }

  function display() {

    // disregard brushes w/o selections
    // ref: http://bl.ocks.org/mbostock/6232537
    if (!d3.event.selection) return;

    // programmed clearing of brush after mouse-up
    // ref: https://github.com/d3/d3-brush/issues/10
    d3.select(this).call(brush.move, null);

    var d_brushed =  d3.selectAll(".brushed").data();
/*
    // populate table if one or more elements is brushed
    if (d_brushed.length > 0) {
      clearTableRows();
      d_brushed.forEach(d_row => populateTableRow(d_row))
    } else {
      clearTableRows();
    }*/
    console.log("hellp")
  }

  var brush = d3.brush()
    .on("brush", highlightBrushedCircles)
    .on("end", display);


  function parseData(url, callBack) {
    Papa.parse(url, {
      download: true,
      dynamicTyping: true,
      complete: function(results) {
        callBack(results.data.slice(1));
      }
    });
  }

  parseData("iris.csv", doStuff);


    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 60},
    width = 460 - margin.left - margin.right,
    height = 450 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
    "translate(" + margin.left + "," + margin.top + ")");





    // Add a tooltip div. Here I define the general feature of the tooltip: stuff that do not depend on the data point.
    // Its opacity is set to 0: we don't see it by default.
    var tooltip = d3.select("#my_dataviz")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "1px")
    .style("border-radius", "5px")
    .style("padding", "10px")



</script>

<script>
  function favTutorial() {

    var mylist = document.getElementById("myList");
    document.getElementById("favourite").value = mylist.options[mylist.selectedIndex].text;
    DR = mylist.options[mylist.selectedIndex].text

    eval ( "Y = new druid."+DR+"(data2).transform()")

    d3.select("#alt_dr").remove();
    var svg2 = d3.select("#my_dataviz2")
      .append("svg")
      .attr("id","alt_dr")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");
    // Add X axis
    var x = d3.scaleLinear()
      .domain(d3.extent(d3.transpose(Y)[0]))
      .range([ 0, width ]);

    svg2.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.zoom().on("zoom", function () {
        svg.attr("transform", d3.event.transform)
      }))
      .call(d3.axisBottom(x));

    // Add Y axis
    var y = d3.scaleLinear()
      .domain(d3.extent(d3.transpose(Y)[1]))
      .range([ 0, height]);
    svg2.append("g")
      .call(d3.axisLeft(y));

    var dots = svg2.append('g')
      .selectAll("dot")
      .data(Y) // the .filter part is just to keep a few dots on the chart, not all of them
      .enter()
      .append("circle")
      .attr("cx", function (d) { return x(d[0]); } )
      .attr("cy", function (d) { return y(d[1]); } )
      .attr("r", 7)
      .style("fill", "#2786a6")
      .style("opacity", 0.3)
      .on("mouseover", mouseover )
      .on("mousemove", function(d){return mousemove(d, adData.selectedVectors)})
      .on("mouseleave", mouseleave )
  }
</script>

<form>
  <b> Choose Alternative Dimensionality  Reduction Method: </b>

  <select id = "myList" onchange = "favTutorial()" >
    <option> ---Methods--- </option>
    <option> TSNE </option>
    <option> UMAP </option>
    <option> FASTMAP </option>
    <option> MDS </option>
    <option> LDA </option>
  </select>
  <p>
    <input type = "text" id = "favourite" size = "20" </p>
</form>
<div id="my_dataviz2"></div>

</body>
</html>
